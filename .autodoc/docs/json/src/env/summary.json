{
  "folderName": "env",
  "folderPath": ".autodoc/docs/json/src/env",
  "url": "/.autodoc/docs/json/src/env",
  "files": [
    {
      "fileName": "client.mjs",
      "filePath": "src/env/client.mjs",
      "url": "/src/env/client.mjs",
      "summary": "This code is responsible for validating and formatting environment variables for the agentgpt project. The code imports two variables, `clientEnv` and `clientSchema`, from a file called `schema.mjs`. `clientEnv` is an object containing environment variables, while `clientSchema` is a schema object that defines the expected structure of `clientEnv`. \n\nThe code then uses the `safeParse` method of `clientSchema` to validate `clientEnv`. If the validation is successful, the validated environment variables are stored in `_clientEnv`. If the validation fails, an error is thrown with a message indicating that the environment variables are invalid.\n\nThe `formatErrors` function takes an object of errors and returns an array of formatted error messages. The function maps over the entries of the error object and checks if the value has an `_errors` property. If it does, the function returns a string with the name of the error and the error messages joined by commas. The function then filters out any falsy values from the resulting array.\n\nThe code then checks if any of the environment variable names in `_clientEnv` do not start with `\"NEXT_PUBLIC_\"`. If any of the names are invalid, an error is thrown with a message indicating that the variable name is invalid.\n\nFinally, the validated environment variables are exported as `env`.\n\nThis code is important for ensuring that the agentgpt project has access to the correct environment variables and that they are in the correct format. The `formatErrors` function is useful for debugging and providing informative error messages to developers. The validation and formatting of environment variables is a crucial step in ensuring that the agentgpt project runs smoothly and without errors. \n\nExample usage:\n```\nimport { env } from \"./env.mjs\";\n\nconsole.log(env.MY_ENV_VAR); // logs the value of MY_ENV_VAR\n```",
      "questions": "1. What is the purpose of the `schema.mjs` file being imported?\n- The `schema.mjs` file is being imported to provide a schema for validating environment variables.\n\n2. What is the purpose of the `formatErrors` function?\n- The `formatErrors` function is used to format validation errors from the Zod schema.\n\n3. What happens if the environment variables fail validation?\n- If the environment variables fail validation, an error message is logged to the console and an error is thrown."
    },
    {
      "fileName": "schema.mjs",
      "filePath": "src/env/schema.mjs",
      "url": "/src/env/schema.mjs",
      "summary": "This code defines the schema for environment variables used in a Next.js project and ensures that the app is not built with invalid environment variables. \n\nThe `serverSchema` object defines the schema for server-side environment variables, including `DATABASE_URL`, `NODE_ENV`, `NEXTAUTH_SECRET`, `NEXTAUTH_URL`, `OPENAI_API_KEY`, `GOOGLE_CLIENT_ID`, `GOOGLE_CLIENT_SECRET`, `GITHUB_CLIENT_ID`, `GITHUB_CLIENT_SECRET`, `DISCORD_CLIENT_ID`, `DISCORD_CLIENT_SECRET`, `STRIPE_SECRET_KEY`, `STRIPE_WEBHOOK_SECRET`, and `STRIPE_SUBSCRIPTION_PRICE_ID`. \n\nThe `clientSchema` object defines the schema for client-side environment variables, including `NEXT_PUBLIC_VERCEL_ENV`, `NEXT_PUBLIC_FF_AUTH_ENABLED`, `NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY`, `NEXT_PUBLIC_FF_SUB_ENABLED`, `NEXT_PUBLIC_FF_MOCK_MODE_ENABLED`, and `NEXT_PUBLIC_VERCEL_URL`. \n\nThe `requiredForProduction` function is used to ensure that certain environment variables are required in production but optional in development and test environments. \n\nThe `stringToBoolean` function is used to preprocess environment variables that are expected to be boolean values. \n\nThe `serverEnv` and `clientEnv` objects are used to manually destructure the `process.env` object and assign the values to the corresponding environment variables defined in the schema objects. \n\nOverall, this code ensures that the app is built with valid environment variables and provides a convenient way to access and use these variables throughout the project. \n\nExample usage:\n```\nimport { serverEnv } from \"agentgpt\";\n\nconst dbUrl = serverEnv.DATABASE_URL;\nconst isProduction = serverEnv.NODE_ENV === \"production\";\n```",
      "questions": "1. What is the purpose of the `serverSchema` and `clientSchema` objects?\n   \n   Answer: The `serverSchema` and `clientSchema` objects specify the schema for the server-side and client-side environment variables respectively. They ensure that the app is not built with invalid environment variables.\n\n2. What is the purpose of the `requiredForProduction` function?\n   \n   Answer: The `requiredForProduction` function returns a Zod schema that requires a string value if the `NODE_ENV` environment variable is set to \"production\", and makes the string value optional otherwise.\n\n3. Why is the `stringToBoolean` function defined?\n   \n   Answer: The `stringToBoolean` function returns a Zod schema that preprocesses a string value to a boolean value. It is used to ensure that environment variables that are expected to be boolean values are correctly parsed."
    },
    {
      "fileName": "server.mjs",
      "filePath": "src/env/server.mjs",
      "url": "/src/env/server.mjs",
      "summary": "This code is responsible for ensuring that the application is not built with invalid environment variables. It is included in the `/next.config.mjs` file and must be a `.mjs` file to be imported there. \n\nThe code imports two modules: `serverSchema` and `serverEnv` from `schema.mjs`, and `clientEnv` and `formatErrors` from `client.mjs`. It then uses `serverSchema` to parse `serverEnv` and stores the result in `_serverEnv`. If `_serverEnv` is not successful, the code logs an error message with the invalid environment variables and throws an error. \n\nNext, the code checks each key in `_serverEnv.data` to see if it starts with \"NEXT_PUBLIC_\". If it does, the code logs a warning message that a server-side environment variable is being exposed and throws an error. \n\nFinally, the code exports an object `env` that combines `_serverEnv.data` and `clientEnv`. This object is likely used throughout the application to access environment variables. \n\nHere is an example of how `env` might be used in the larger project:\n\n```\nimport { env } from \"./env.mjs\";\n\nconst API_KEY = env.API_KEY;\nconst API_URL = env.API_URL;\n\nfetch(`${API_URL}/data`, {\n  headers: {\n    Authorization: `Bearer ${API_KEY}`,\n  },\n})\n  .then((response) => response.json())\n  .then((data) => console.log(data))\n  .catch((error) => console.error(error));\n```\n\nIn this example, `env` is used to access the `API_KEY` and `API_URL` environment variables, which are used to make an API request.",
      "questions": "1. What is the purpose of the `schema.mjs` and `client.mjs` files being imported?\n   - The `schema.mjs` and `client.mjs` files are being imported to be used in validating and formatting environment variables.\n2. What happens if the server environment variables are invalid?\n   - If the server environment variables are invalid, an error message will be logged to the console and an error will be thrown.\n3. Why is there a check for environment variables starting with \"NEXT_PUBLIC_\"?\n   - There is a check for environment variables starting with \"NEXT_PUBLIC_\" because these variables are meant to be exposed to the client-side only, and exposing them on the server-side could pose a security risk."
    }
  ],
  "folders": [],
  "summary": "The code in the `env` folder is responsible for validating, formatting, and ensuring the correct usage of environment variables in the agentgpt project. It consists of three files: `client.mjs`, `schema.mjs`, and `server.mjs`.\n\n`client.mjs` validates and formats the client-side environment variables. It imports `clientEnv` and `clientSchema` from `schema.mjs`, and uses the `safeParse` method to validate `clientEnv`. If the validation is successful, the validated environment variables are stored in `_clientEnv`. The `formatErrors` function is used to provide informative error messages in case of validation failures. The code also checks if any variable names in `_clientEnv` do not start with `\"NEXT_PUBLIC_\"` and throws an error if any invalid names are found. The validated environment variables are exported as `env`.\n\nExample usage of `client.mjs`:\n```javascript\nimport { env } from \"./env.mjs\";\n\nconsole.log(env.MY_ENV_VAR); // logs the value of MY_ENV_VAR\n```\n\n`schema.mjs` defines the schema for environment variables used in the project. It contains two schema objects: `serverSchema` for server-side environment variables and `clientSchema` for client-side environment variables. The `requiredForProduction` function ensures that certain variables are required in production but optional in development and test environments. The `stringToBoolean` function preprocesses environment variables that are expected to be boolean values. The `serverEnv` and `clientEnv` objects destructure the `process.env` object and assign the values to the corresponding environment variables defined in the schema objects.\n\nExample usage of `schema.mjs`:\n```javascript\nimport { serverEnv } from \"agentgpt\";\n\nconst dbUrl = serverEnv.DATABASE_URL;\nconst isProduction = serverEnv.NODE_ENV === \"production\";\n```\n\n`server.mjs` ensures that the application is not built with invalid environment variables. It imports `serverSchema`, `serverEnv`, `clientEnv`, and `formatErrors`. It uses `serverSchema` to parse `serverEnv` and stores the result in `_serverEnv`. If the parsing is unsuccessful, it logs an error message with the invalid environment variables and throws an error. The code also checks each key in `_serverEnv.data` to see if it starts with \"NEXT_PUBLIC_\" and throws an error if it does. Finally, it exports an object `env` that combines `_serverEnv.data` and `clientEnv`.\n\nExample usage of `server.mjs`:\n```javascript\nimport { env } from \"./env.mjs\";\n\nconst API_KEY = env.API_KEY;\nconst API_URL = env.API_URL;\n\nfetch(`${API_URL}/data`, {\n  headers: {\n    Authorization: `Bearer ${API_KEY}`,\n  },\n})\n  .then((response) => response.json())\n  .then((data) => console.log(data))\n  .catch((error) => console.error(error));\n```\n\nIn summary, the code in the `env` folder plays a crucial role in managing environment variables for the agentgpt project. It ensures that the variables are valid, correctly formatted, and used appropriately throughout the application.",
  "questions": ""
}